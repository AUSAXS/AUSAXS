// SPDX-License-Identifier: LGPL-3.0-or-later
// Author: Kristian Lytje

#pragma once

#include <math/Vector3.h>
#include <math/MatrixUtils.h>

#include <cassert>

namespace ausaxs::symmetry {
    class Symmetry {
        bool sanity_checks() const;
        public:
            struct _Relation; struct _Repeat;

            Symmetry() = default;
            Symmetry(_Relation initial_relation, _Repeat repeat_relation, int repetitions = 1)
                : initial_relation(initial_relation), repeat_relation(repeat_relation), repetitions(repetitions)
            {assert(sanity_checks());}

            Symmetry(Vector3<double> offset, Vector3<double> repeat_translation, Vector3<double> repeat_axis, double repeat_rotation, int repetitions = 1)
                : initial_relation(offset), repeat_relation(repeat_translation, repeat_axis, repeat_rotation), repetitions(repetitions)
            {assert(sanity_checks());}

            /**
            * @brief Get the transform taking the original structure to the N-th repeat.
            *
            * @param cm  The center of mass of the original body.
            * @param rep The repeat index (1 = first copy, 2 = second copy, ...).
            */
            template<typename T>
            std::function<Vector3<T>(Vector3<T>)> get_transform(const Vector3<double>& cm, int rep = 1) const;

            /**
            * @brief Determine if the symmetry is closed, i.e. the (repetitions+1)-th copy coincides with the original.
            */
            bool is_closed() const;

            bool operator==(const Symmetry& rhs) const = default;

            // Positional offset of the original body from the center of rotation.
            struct _Relation {
                _Relation() : translation{0, 0, 0} {}
                _Relation(const Vector3<double>& t) : translation(t) {}

                Vector3<double> translation;
                bool operator==(const _Relation& rhs) const = default;
            } initial_relation;

            // Per-step symmetry operation: axis/angle rotation + optional axial translation.
            // The rotation axis and angle fully describe a single-axis rotation; the translation (if any) must be collinear with the axis.
            struct _Repeat {
                _Repeat() : translation{0, 0, 0}, axis{0, 0, 1}, angle(0) {}
                _Repeat(const Vector3<double>& t, const Vector3<double>& axis, double angle)
                    : translation(t), axis(axis), angle(angle) 
                {}

                _Repeat(const Vector3<double>& axis, double angle)
                    : translation{0, 0, 0}, axis(axis), angle(angle) 
                {}

                Vector3<double> translation;    // per-step translation (e.g. for screw symmetries)
                Vector3<double> axis;           // rotation axis
                double angle;                   // per-step rotation angle in radians
                bool operator==(const _Repeat& rhs) const = default;
            } repeat_relation;
            int repetitions; // number of repeats (copies) generated by this symmetry; must be >= 1
        };
        static_assert(std::is_standard_layout_v<Symmetry>,  "Symmetry is not standard layout");
        static_assert(supports_nothrow_move_v<Symmetry>,    "Symmetry should support nothrow move semantics.");

    inline bool Symmetry::sanity_checks() const {
        assert(1 <= repetitions && "Zero or negative repeats does not make sense.");
        assert(initial_relation.translation.dot(repeat_relation.translation) == 0 && "The translation vectors must be orthogonal.");
        assert([&]() {
            if (1e-6 < std::abs(repeat_relation.angle)) { return 1e-6 < repeat_relation.axis.magnitude(); }
            return true;
        }() && "Rotation angle is non-zero but rotation axis is zero vector.");
        assert([&]() {
            auto normed_axis = repeat_relation.axis / repeat_relation.axis.magnitude();
            auto R_r = matrix::rotation_matrix<double>(normed_axis, repeat_relation.angle);
            return std::abs(repeat_relation.angle) < 1e-6 || R_r*repeat_relation.translation == repeat_relation.translation;
        }() && "The translation vector must lie in the invariant space of the rotation matrix.");
        return true;
    }
}

template<typename Q>
inline std::function<ausaxs::Vector3<Q>(ausaxs::Vector3<Q>)> ausaxs::symmetry::Symmetry::get_transform(const Vector3<double>& cm, int rep) const {
    Matrix<double>  R_final;
    Vector3<double> T_final;

    {
        auto t_i = initial_relation.translation;
        auto t_r = repeat_relation.translation;
        auto normed_axis = repeat_relation.axis / repeat_relation.axis.magnitude();
        assert(sanity_checks());
        assert((
            1e-6 < t_r.magnitude() || 1e-6 < std::abs(repeat_relation.angle)
            || (rep == 1 && 1e-6 < t_i.magnitude())
        ) && "The symmetry is trivial; no transformation to apply.");

        // The symmetric ensemble is generated by:
        //   For copy k: v_k = R_r^k*(v - cm) + R_r^k*t_i - t_i + sum_{j=1}^{k} R_r^{j-1}*t_r + cm
        //
        // Accumulated iteratively:
        //   base_T = cm - r_r*cm + (r_r*t_i + t_r - t_i)   (k=1 translation)
        //   R_k    = r_r^k
        //   T_k    = r_r * T_{k-1} + base_T,   T_1 = base_T
        auto R_r = matrix::rotation_matrix<double>(normed_axis, repeat_relation.angle);
        auto base_T = cm - R_r * cm + (R_r * t_i + t_r - t_i);
        R_final = R_r;
        T_final = base_T;
        for (int i = 1; i < rep; ++i) {
            T_final = R_r*T_final + base_T;
            R_final = R_r*R_final;
        }
    }

    if constexpr (std::is_same_v<Q, double>) {
        return [R_final=std::move(R_final), T_final=std::move(T_final)](Vector3<Q> v) {
            return R_final*v + T_final;
        };
    }

    // cast to requested precision for better performance
    Matrix<Q>  R_cast = std::move(R_final);
    Vector3<Q> T_cast = std::move(T_final);
    return [R_cast=std::move(R_cast), T_cast=std::move(T_cast)](Vector3<Q> v) {
        return R_cast*v + T_cast;
    };
}

inline bool ausaxs::symmetry::Symmetry::is_closed() const {
    if (repeat_relation.translation.magnitude() != 0) { return false; }
    if (std::abs(repeat_relation.angle) < 1e-9) { return true; }

    // (repetitions+1) steps must accumulate to a multiple of 2pi
    double total = (repetitions + 1) * repeat_relation.angle;
    constexpr int cmp = 628; // 100*2pi rounded to nearest integer
    int rounded = static_cast<int>(std::round(100 * std::abs(total)));
    return (rounded % cmp) == 0;
}
